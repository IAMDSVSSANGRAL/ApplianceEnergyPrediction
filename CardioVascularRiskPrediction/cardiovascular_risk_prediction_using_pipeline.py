# -*- coding: utf-8 -*-
"""Cardiovascular risk prediction using Pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12SUuZeExPYkMfcofnth8mICz1V5Th8Uq

# **Project Name**    - Cardiovascular risk prediction

##### **Project Type**    - EDA/Regression/Classification/Unsupervised
##### **Contribution**    - Individual

# **Project Summary -**

**Project Summary: Predicting Coronary Heart Disease Risk**

This project aims to develop a machine learning model to predict the risk of coronary heart disease (CHD) within the next 10 years for patients in Framingham, Massachusetts. The dataset includes records of over 4,000 patients, with 15 attributes covering demographic, behavioral, and medical risk factors.

The focus is on binary classification, with the target variable "TenYearCHD" indicating whether a patient is at risk (1) or not (0). Features include age, sex, education, smoking status, blood pressure, and cholesterol levels. Handling missing values and ensuring data consistency are critical during data preprocessing.

Feature engineering involves crafting new features or transforming existing ones to enhance model performance. Model selection includes exploring algorithms like logistic regression, decision trees, random forests, and support vector machines, evaluated on metrics like accuracy, precision, recall, and F1-score.

Hyperparameter tuning fine-tunes model performance using techniques like grid search or randomized search. Model evaluation involves assessing performance metrics and ensuring generalizability through cross-validation.

The success of the project is measured by the model's ability to accurately predict CHD risk, enabling healthcare professionals to identify high-risk individuals for timely interventions and personalized healthcare recommendations.

In conclusion, this project aims to leverage machine learning to predict CHD risk, contributing to preventive healthcare efforts and potentially reducing the burden of cardiovascular diseases.

# **GitHub Link -**

Provide your GitHub Link here.

https://github.com/IAMDSVSSANGRAL/classificationcapestone

# **Problem Statement**

The objective of this project is to develop a machine learning model that can predict whether a patient is at risk of developing coronary heart disease (CHD) within the next 10 years. The dataset used for this project contains records of over 4,000 patients from an ongoing cardiovascular study in Framingham, Massachusetts. Each record consists of 15 attributes, including demographic, behavioral, and medical risk factors.

The primary task is binary classification, where the target variable is "TenYearCHD," indicating whether a patient is at risk of CHD (1) or not (0). The features include attributes such as age, sex, education level, smoking status, blood pressure measurements, cholesterol levels, and more. The dataset may also contain missing values that need to be handled appropriately.

By building an accurate predictive model, this project aims to assist healthcare professionals in identifying individuals at higher risk of CHD, allowing for early intervention and tailored healthcare recommendations to reduce the incidence of cardiovascular diseases.

Key objectives for the project include data preprocessing, feature engineering, model selection, hyperparameter tuning, and evaluating the model's performance using appropriate metrics. The success of this project will be measured by the model's ability to predict CHD risk with a high degree of accuracy and reliability.

# **General Guidelines** : -

1.   Well-structured, formatted, and commented code is required.
2.   Exception Handling, Production Grade Code & Deployment Ready Code will be a plus. Those students will be awarded some additional credits.
     
     The additional credits will have advantages over other students during Star Student selection.
       
             [ Note: - Deployment Ready Code is defined as, the whole .ipynb notebook should be executable in one go
                       without a single error logged. ]

3.   Each and every logic should have proper comments.
4. You may add as many number of charts you want. Make Sure for each and every chart the following format should be answered.
        

```
# Chart visualization code
```
            

*   Why did you pick the specific chart?
*   What is/are the insight(s) found from the chart?
* Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

5. You have to create at least 15 logical & meaningful charts having important insights.


[ Hints : - Do the Vizualization in  a structured way while following "UBM" Rule.

U - Univariate Analysis,

B - Bivariate Analysis (Numerical - Categorical, Numerical - Numerical, Categorical - Categorical)

M - Multivariate Analysis
 ]





6. You may add more ml algorithms for model creation. Make sure for each and every algorithm, the following format should be answered.


*   Explain the ML Model used and it's performance using Evaluation metric Score Chart.


*   Cross- Validation & Hyperparameter Tuning

*   Have you seen any improvement? Note down the improvement with updates Evaluation metric Score Chart.

*   Explain each evaluation metric's indication towards business and the business impact pf the ML model used.

# ***Let's Begin !***

## ***1. Know Your Data***

### Import Libraries
"""

# Import Libraries
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns
import missingno as msno

import warnings
warnings.filterwarnings('ignore')

from google.colab import drive
#importing necessary liabrary for handling missing values
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder
from sklearn.neighbors import LocalOutlierFactor
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline,make_pipeline

"""### Dataset Loading"""

#mounting the google drive
drive.mount('/content/drive')

#assinging the path
path = "/content/drive/MyDrive/Almabetter Santa/classification - capestone/data_cardiovascular_risk.csv"

#read data from a CSV file into a DataFrame.
data_raw = pd.read_csv(path)

#create a copy of raw data
df = data_raw.copy()

"""### Dataset First View"""

# Dataset First Look
df.sample(5)

"""### Dataset Rows & Columns count"""

# Dataset Rows & Columns count
rows, columns = df.shape

# Print the number of rows and columns
print("Number of Rows:", rows)
print("Number of Columns:", columns)

"""### Dataset Information"""

# Dataset Info
df.info()

"""#### Duplicate Values"""

# Dataset Duplicate Value Count
duplicate_count = df.duplicated().sum()

# Print the count of duplicate values
print("Duplicate Value Count:", duplicate_count)

"""#### Missing Values/Null Values"""

# Missing Values/Null Values Count
missing_values_count = df.isnull().sum()

# Print the count of missing values for each column
print("Missing Values Count:")
print(missing_values_count)

#installing missingno
!pip install missingno

# Visualizing the missing values
plt.figure(figsize=(10, 6))  # Adjust the figure size as needed
missing_values_count.plot(kind='bar', color='red')
plt.xlabel('Columns')
plt.ylabel('Null Value Count')
plt.title('Null Value Counts by Column')
plt.xticks(rotation=90)  # Rotate the x-axis labels for better visibility
plt.show()

# Visualizing the missing values

msno.matrix(df)
plt.title('Missing Data Matrix')
plt.show()

"""### What did you know about your dataset?

There are several insights that can be gathered from the information provided about your dataset:

1. **Number of Entries:**
   - The dataset contains 3,390 entries.

2. **Columns and Data Types:**
   - There are 17 columns in the dataset.
   - The data types include integers (`int64`), floats (`float64`), and objects (`object`).

3. **Missing Values:**
   - Some columns have missing values (non-null counts are less than the total number of entries).
   - Columns with missing values include 'education', 'cigsPerDay', 'BPMeds', 'totChol', 'BMI', 'heartRate', and 'glucose'.

4. **Categorical Columns:**
   - 'sex' and 'is_smoking' are categorical columns represented as objects. You may want to check the unique values in these columns and potentially convert them to numerical values if needed.

5. **Numerical Columns:**
   - Columns such as 'age', 'education', 'cigsPerDay', 'BPMeds', 'totChol', 'sysBP', 'diaBP', 'BMI', 'heartRate', 'glucose' are numerical.

6. **Target Variable:**
   - 'TenYearCHD' is the target variable for binary classification, indicating whether a patient is at risk of CHD in the next 10 years.

7. **Summary Statistics:**
   - Descriptive statistics such as mean, standard deviation, minimum, and maximum are not provided, but calculating these would be useful for understanding the distribution of numerical features.

8. **Potential Preprocessing Steps:**
   - Imputation: Consider imputing missing values for columns like 'education', 'cigsPerDay', 'BPMeds', 'totChol', 'BMI', 'heartRate', and 'glucose'.
   - Categorical Encoding: Convert categorical columns ('sex' and 'is_smoking') into numerical format, possibly using one-hot encoding or label encoding.
   - Feature Scaling: Depending on the algorithms you plan to use, consider scaling numerical features.

These initial insights provide a foundation for further exploration and preprocessing of the dataset. You can visualize the distribution of numerical features, explore relationships between variables, and handle missing values before building and training your machine learning model.

## ***2. Understanding Your Variables***
"""

# Assuming data_raw is your DataFrame
columns_list = df.columns

# Print the list of columns
print("Dataset Columns:")
print(columns_list)

# Dataset Describe
df.describe(include="all")

"""### Variables Description

![Classification_Cardiovascular_Risk_Prediction_8e8765e394.png](data:image/png;base64,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)

### Check Unique Values for each variable.
"""

# Check Unique Values for each variable.
for column in df.columns:
    unique_values = df[column].unique()
    print(f'Unique values in column "{column}":')
    print(unique_values)
    print('\n')

"""## 3. ***Data Wrangling***"""

df.info()

df.isna().sum()

"""### Feature Manipulation"""

def blood_presure_classification(SysBP, DiaBP):
  if (SysBP < 90) or (DiaBP < 60):
    return 0 # 'Hypotension'
  if (SysBP < 120) and (DiaBP < 80):
    return 1 # 'Optimal'
  if (SysBP < 130) or (DiaBP < 86):
    return 2 # 'Normal'
  if (SysBP < 140) or (DiaBP < 90):
    return 3 # 'PreHypertensive'
  if (SysBP > 140) and (DiaBP < 90):
    return 4 # 'IsolatedSystolicHypertension'
  if (SysBP < 160) or (DiaBP < 100):
    return 5 # 'GradeI'
  if (SysBP < 180) or (DiaBP < 110):
    return 6 # 'GradeII'
  return 7 # 'GradeIII'

#Creating new feature Hypertension
df['Hypertension'] = df.apply(lambda x: blood_presure_classification(x['sysBP'],x['diaBP']),axis=1)

def diabetes_grade(glucose):
  if glucose < 100:
    return 1 # 'Normal'
  if glucose < 125:
    return 2 # 'Prediabetic'
  if glucose < 200:
    return 3 # 'Mild'
  if glucose < 400:
    return 4 # 'Moderate'
  return 5 # 'Severe'

#Creating new feature Diabetes
df['Diabetes_grade'] = df['glucose'].apply(lambda x: diabetes_grade(x))

# Calculating MAP using 'SysBP' and 'DiaBP'.
df["mean_art_pressure"] = (df["sysBP"] + 2 * df["diaBP"])/3

# remove not useful columns
df.drop(columns=['id','sysBP', 'diaBP', 'glucose'], inplace=True)

df.head()

df.isna().sum()

"""### What all manipulations have you done and insights you found?

Right now i just drop the ID column as it is not relevant in predicting the 'TenyearCHD'

created 3 lists containing the column names which will be helpful for further manipulation.

### Missing Value Imputation
"""

# List of columns to plot
columns_to_plot = ['education','cigsPerDay', 'BPMeds', 'totChol', 'BMI', 'glucose', 'heartRate']

# Set up subplots
fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(12, 14))
fig.tight_layout(pad=5.0)

# Check if there are enough subplots for the columns to plot
if len(columns_to_plot) > len(axes.flatten()):
    raise ValueError("Not enough subplots for the number of columns to plot.")

for i, column in enumerate(columns_to_plot):
    # Plot distribution
    sns.histplot(data_raw[column], kde=True, ax=axes[i // 2, i % 2], color='skyblue')

    # Annotate with mean, median, mode
    mean_value = data_raw[column].mean()
    median_value = data_raw[column].median()
    mode_value = data_raw[column].mode().values[0]

    axes[i // 2, i % 2].axvline(mean_value, color='red', linestyle='dashed', linewidth=2, label=f'Mean: {mean_value:.2f}')
    axes[i // 2, i % 2].axvline(median_value, color='green', linestyle='dashed', linewidth=2, label=f'Median: {median_value:.2f}')
    axes[i // 2, i % 2].axvline(mode_value, color='yellow', linestyle='dashed', linewidth=2, label=f'Mode: {mode_value}')

    axes[i // 2, i % 2].legend()
    axes[i // 2, i % 2].set_title(f'Distribution of {column}')

plt.show()

df.head()

import pandas as pd

def handle_outliers_iqr(df, cols=None, threshold=1.5):
    if cols is None:
        cols = df.select_dtypes(include=['float64', 'int64']).columns  # Select numerical columns
    for col in cols:
        q1 = df[col].quantile(0.25)
        q3 = df[col].quantile(0.75)
        iqr = q3 - q1
        upper_bound = q3 + threshold * iqr
        lower_bound = q1 - threshold * iqr
        df[col] = df[col].apply(lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x))
    return df

# Columns to exclude from outlier detection
exclude_cols = ['sex', 'is_smoking','TenYearCHD']

# Get numerical columns except for excluded columns
numeric_cols = [col for col in df.columns if col not in exclude_cols]

# Apply outlier detection
df_processed = handle_outliers_iqr(df, cols=numeric_cols)

# Display the processed DataFrame
print(df_processed)

df_processed.shape

"""## ***4. Data Vizualization, Storytelling & Experimenting with charts : Understand the relationships between variables***

#### Chart - 1 - Box Plot of Systolic/Diastolic Blood Pressure by TenYearCHD Status
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Set the style for the plots
sns.set(style="whitegrid")

# Set the color palette
colors = ["#3498db", "#e74c3c"]

# Box plot for Systolic Blood Pressure (sysBP) - Training dataset
plt.figure(figsize=(10, 3))
sns.boxplot(x=y_train, y='sysBP', data=X_train_transformed_df, palette=colors)
plt.title('Box Plot of Systolic Blood Pressure by TenYearCHD Status (Training)', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Systolic Blood Pressure (sysBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# Box plot for Diastolic Blood Pressure (diaBP) - Training dataset
plt.figure(figsize=(10, 3))
sns.boxplot(x=y_train, y='diaBP', data=X_train_transformed_df, palette=colors)
plt.title('Box Plot of Diastolic Blood Pressure by TenYearCHD Status (Training)', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Diastolic Blood Pressure (diaBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# Box plot for Systolic Blood Pressure (sysBP) - Testing dataset
plt.figure(figsize=(10, 3))
sns.boxplot(x=y_test , y='sysBP', data=X_test_transformed_df, palette=colors)
plt.title('Box Plot of Systolic Blood Pressure by TenYearCHD Status (Testing)', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Systolic Blood Pressure (sysBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# Box plot for Diastolic Blood Pressure (diaBP) - Testing dataset
plt.figure(figsize=(10, 3))
sns.boxplot(x=y_test , y='diaBP', data=X_test_transformed_df, palette=colors)
plt.title('Box Plot of Diastolic Blood Pressure by TenYearCHD Status (Testing)', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Diastolic Blood Pressure (diaBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Set the style for the plots
sns.set(style="whitegrid")

# Set the color palette
colors = ["#3498db", "#e74c3c"]

# Box plot for Systolic Blood Pressure (sysBP)
plt.figure(figsize=(10, 3))
sns.boxplot(x='TenYearCHD', y='sysBP', data=df, palette=colors)
plt.title('Box Plot of Systolic Blood Pressure by TenYearCHD Status', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Systolic Blood Pressure (sysBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# Box plot for Diastolic Blood Pressure (diaBP)
plt.figure(figsize=(10, 3))
sns.boxplot(x='TenYearCHD', y='diaBP', data=df, palette=colors)
plt.title('Box Plot of Diastolic Blood Pressure by TenYearCHD Status', fontsize=16)
plt.xlabel('TenYearCHD Status (0: No CHD, 1: CHD)', fontsize=14)
plt.ylabel('Diastolic Blood Pressure (diaBP)', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

"""##### 1. Why did you pick the specific chart?

The box plot was chosen for its ability to effectively display the distribution of blood pressure measurements for patients with and without CHD risk. Its simplicity, along with clear representation of central tendency and variability, makes it suitable for comparing groups and identifying potential differences in blood pressure levels.

##### 2. What is/are the insight(s) found from the chart?

It is clearly visible the High systolic and Diastolic blood pressure for the person having Ten Year CHD.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained from comparing blood pressure measurements between patients with and without CHD risk can help in creating positive business impact by informing healthcare interventions and personalized treatment plans, potentially reducing the incidence of cardiovascular diseases. However, if significant disparities in blood pressure levels exist, it may highlight disparities in access to healthcare, leading to negative growth.

#### Chart - 2 side-by-side comparison of the distribution of total cholesterol levels for patients
"""

# Chart - 2 visualization code
# Set up the figure with subplots
plt.figure(figsize=(12, 6))

# Plot histogram for CHD = 0 (No CHD)
plt.subplot(1, 2, 1)
sns.histplot(df[df['TenYearCHD'] == 0]['totChol'], bins=30, kde=True, color='blue')
plt.title('Distribution of Total Cholesterol for No CHD')
plt.xlabel('Total Cholesterol')
plt.ylabel('Frequency')

# Plot histogram for CHD = 1 (With CHD)
plt.subplot(1, 2, 2)
sns.histplot(df[df['TenYearCHD'] == 1]['totChol'], bins=30, kde=True, color='red')
plt.title('Distribution of Total Cholesterol for CHD')
plt.xlabel('Total Cholesterol')
plt.ylabel('Frequency')

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()

"""##### 1. Why did you pick the specific chart?

The histogram was chosen for its effectiveness in displaying the distribution of total cholesterol levels for patients with and without CHD. Its simplicity and ability to show frequency distributions make it suitable for comparing data between groups and identifying potential patterns or differences.

##### 2. What is/are the insight(s) found from the chart?

The insight from the chart is that individuals with CHD tend to have a higher frequency of total cholesterol levels in the range of 200 to 300 compared to those without CHD. Additionally, there are outliers with total cholesterol levels exceeding 400, suggesting potential extreme cases or outliers within the CHD group.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained regarding the association between total cholesterol levels and CHD risk can contribute to positive business impact by informing preventive healthcare strategies, personalized treatment plans, and interventions aimed at reducing CHD incidence, thus potentially improving patient outcomes and reducing healthcare costs.

#### Chart - 3 "Comparison of BMI Distribution between Patients with and without CHD"
"""

# Chart - 3 visualization code
# Set up the figure with subplots
plt.figure(figsize=(12, 6))

# Plot histogram for CHD = 0 (No CHD)
plt.subplot(1, 2, 1)
sns.histplot(df[df['TenYearCHD'] == 0]['BMI'], bins=30, kde=True, color='blue')
plt.title('Distribution of BMI for No CHD')
plt.xlabel('BMI (Body Mass Index)')
plt.ylabel('Frequency')

# Plot histogram for CHD = 1 (With CHD)
plt.subplot(1, 2, 2)
sns.histplot(df[df['TenYearCHD'] == 1]['BMI'], bins=30, kde=True, color='red')
plt.title('Distribution of BMI for CHD')
plt.xlabel('BMI (Body Mass Index)')
plt.ylabel('Frequency')

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()

"""##### 1. Why did you pick the specific chart?

Answer Here.The histogram was chosen because it effectively visualizes the distribution of BMI (Body Mass Index) for patients with and without CHD. Its simplicity and ability to show frequency distributions make it suitable for comparing BMI between groups and identifying potential associations with CHD risk.

##### 2. What is/are the insight(s) found from the chart?

Not a big difference in BMI distribution, there is few outlier in BMI OF CHD person.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Insights on the BMI distribution may not significantly impact business positively, but identifying outliers in BMI among CHD patients can inform targeted interventions, potentially reducing adverse health outcomes and healthcare costs.

#### Chart - 4 "Comparison of Heart Rate between Patients with and without CHD"
"""

# Chart - 4 visualization code
# Set up the figure with subplots
plt.figure(figsize=(10, 6))

# Box plot for heart rates based on CHD status
sns.boxplot(x='TenYearCHD', y='heartRate', data=df)
plt.title('Heart Rate Comparison for Different CHD Status')
plt.xlabel('TenYearCHD')
plt.ylabel('Heart Rate')

# Show the plot
plt.show()

"""##### 1. Why did you pick the specific chart?

The box plot was selected because it effectively compares the distribution of heart rates between patients with and without CHD. Its ability to show the central tendency, spread, and any potential outliers in the data makes it suitable for comparing continuous variables across different groups.

##### 2. What is/are the insight(s) found from the chart?

No big difference in Heart rate of patient with or without CHD , but If your heart rate is over 100 beats per minute when you are at rest, this is considered fast. A rapid heart rate, also known as tachycardia, can be related to many different health conditions. It's normal for your heart rate to increase when you're exercising or if your body is fighting off an infection.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Insights on heart rate differences between CHD and non-CHD patients may not directly impact business positively. However, identifying elevated heart rates (>100 bpm) among individuals can prompt targeted healthcare interventions, potentially mitigating health risks and reducing healthcare costs. Failure to address elevated heart rates may lead to negative health outcomes, impacting business productivity and healthcare expenses.

#### Chart - 5 Comparison of Glucose Distribution between Patients with and without CHD
"""

# Chart - 5 visualization code
# Set up the figure with subplots
plt.figure(figsize=(12, 6))

# Plot histogram for CHD = 0 (No CHD)
plt.subplot(1, 2, 1)
sns.histplot(df[df['TenYearCHD'] == 0]['glucose'], bins=30, kde=True, color='blue')
plt.title('Distribution of Glucose for No CHD')
plt.xlabel('Glucose Level')
plt.ylabel('Frequency')

# Plot histogram for CHD = 1 (With CHD)
plt.subplot(1, 2, 2)
sns.histplot(df[df['TenYearCHD'] == 1]['glucose'], bins=30, kde=True, color='red')
plt.title('Distribution of Glucose for CHD')
plt.xlabel('Glucose Level')
plt.ylabel('Frequency')

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()

"""##### 1. Why did you pick the specific chart?

The histogram was chosen because it effectively displays the distribution of glucose levels for patients with and without CHD. Its simplicity and ability to show frequency distributions make it suitable for comparing glucose levels between groups and identifying potential associations with CHD risk.

##### 2. What is/are the insight(s) found from the chart?

No significant change is visible.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Answer HereInsights into glucose level distributions may aid in creating positive business impact by informing preventive healthcare measures and personalized interventions, potentially reducing the risk of CHD and associated healthcare costs. However, if significant disparities or abnormalities in glucose levels exist, they could indicate underlying health issues, leading to negative growth due to increased healthcare expenses and decreased productivity.

#### Chart - 6 - "Prevalence of Hypertension Across Age Groups"
"""

# Chart - 6 visualization code
# Set up the figure with subplots
plt.figure(figsize=(14, 6))

# Plot the prevalence of hypertension for different age groups
sns.countplot(x='age', hue='prevalentHyp', data=df, palette='viridis')
plt.title("Prevalence of Hypertension Across Age Groups")
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.legend(title='Prevalent Hypertension')

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()

"""##### 1. Why did you pick the specific chart?

The countplot was chosen because it effectively displays the prevalence of hypertension across different age groups, making it easy to observe trends and variations in hypertension counts among patients with and without CHD. Its simplicity and ability to show categorical data with hue differentiation make it suitable for comparing hypertension prevalence across age groups.

##### 2. What is/are the insight(s) found from the chart?

The insights from the chart indicate that the prevalence of hypertension varies across different age groups, with notable differences between patients with and without CHD. For patients without CHD, hypertension counts peak around age 40 and then decline, while for those with CHD, hypertension counts continue to rise until around age 63 before declining. This suggests potential age-related trends in hypertension prevalence among patients with and without CHD.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

The insights on hypertension prevalence across age groups can positively impact businesses by informing targeted healthcare interventions and preventive measures, potentially reducing the incidence of cardiovascular diseases like CHD and associated healthcare costs. However, if hypertension prevalence remains high or increases with age, it may lead to negative growth due to elevated healthcare expenses and decreased workforce productivity associated with managing hypertension-related complications.

#### Chart - 7 -- Prevalence of Diabetes for Different Age Groups
"""

# Chart - 7 visualization code
# Set up the figure with subplots
plt.figure(figsize=(14, 6))
# Plot the prevalence of diabetes for different age groups
sns.countplot(x='age', hue='diabetes', data=df, palette='muted')
plt.title('Prevalence of Diabetes for Different Age Groups')
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.legend(title='Diabetes')

# Adjust layout
plt.tight_layout()

# Show the plots
plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a countplot because it effectively displays the prevalence of diabetes across different age groups using categorical data.

##### 2. What is/are the insight(s) found from the chart?

From the chart, it appears that there may be a higher prevalence of diabetes among individuals without coronary heart disease (CHD) compared to those with CHD, as indicated by the taller towers in the "No CHD" category compared to the "CHD" category. This insight suggests a potential correlation between diabetes and the absence of coronary heart disease, which could be further explored for implications in preventive healthcare and treatment strategies.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights regarding the higher prevalence of diabetes among individuals without coronary heart disease could potentially lead to positive business impacts in healthcare, informing targeted prevention and management strategies. However, misinterpretation or inadequate contextualization of the insights could lead to negative growth implications, such as misguided treatment approaches or misallocation of resources.

#### Chart - 8
"""

# Chart - 8 visualization code
# Plot the distribution of education levels
plt.figure(figsize=(10, 6))
sns.countplot(x='education', data=df, palette='Set2')
plt.title('Distribution of Education Levels')
plt.xlabel('Education Level')
plt.ylabel('Count')

# Show the plot
plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a countplot to visualize the distribution of education levels because it effectively displays the frequency of each category within a single categorical variable. This allows for easy comparison of the education levels present in the dataset, providing insight into the educational demographics of the population.

##### 2. What is/are the insight(s) found from the chart?

The insight from the chart suggests that there are higher numbers of individuals with education level 1.0 compared to those with education levels 2.0, 3.0, and 4.0. This indicates that the majority of the population in the dataset likely has education level 1.0, followed by decreasing numbers for higher education levels. This insight can be useful for understanding the educational distribution within the dataset and potentially identifying any patterns or disparities in educational attainment among the population.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

The insight that education level 1.0 has higher numbers than 2.0, 3.0, and 4.0 could potentially lead to positive business impacts by informing targeted marketing or educational campaigns tailored to individuals with varying education levels. However, if the distribution of education levels is skewed due to biases in the dataset or if it does not accurately represent the target market, it could lead to negative growth implications by misguiding business decisions or resource allocations. Therefore, it's important to validate the insights and consider other relevant factors before implementing any strategies based on them.

#### Chart - 9 - Relationship between TenYearCHD and continous variable
"""

# Chart - 9 visualization code
# Relationship between the dependent variable and continuous independent variables with the help of catplot named violinplot
for i in continuous_var:
    sns.violinplot(data=df, x="TenYearCHD", y=i, hue="sex", split=True, inner="quart")
    plt.title(f'Relationship between TenYearCHD and {i}')
    plt.tight_layout()
    plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a violin plot to visualize the relationship between the dependent variable (TenYearCHD) and continuous independent variables because it effectively displays the distribution of the continuous variable across different categories of the dependent variable. The split violin plot also allows for easy comparison between categories, while the addition of hue (sex) provides further insights into potential gender differences within the data. Overall, the violin plot offers a comprehensive view of the relationship between TenYearCHD and each continuous independent variable, aiding in understanding the data's patterns and distributions.

##### 2. What is/are the insight(s) found from the chart?

Vatious distrubution pattern has been seen for men an women having chd and also do not have chd , some amazing pattern are visible here.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

The insights gained from the violin plots could potentially lead to positive business impacts by providing valuable information about the relationship between the risk of coronary heart disease (TenYearCHD) and various continuous independent variables, such as age, cholesterol levels, or blood pressure. These insights can inform the development of targeted prevention and intervention strategies, potentially leading to improved healthcare outcomes and reduced risks for individuals at higher risk of CHD.

However, if the insights reveal concerning patterns, such as a strong association between certain continuous variables and a higher risk of CHD, it could lead to negative growth implications. For instance, if the plots show that individuals with elevated cholesterol levels or blood pressure have a significantly higher risk of CHD, it could indicate a need for more intensive interventions or treatments for these individuals. Failure to address these risks adequately could lead to negative health outcomes and increased healthcare costs in the long run. Therefore, it's crucial to carefully analyze the insights and implement appropriate measures to mitigate any negative impacts.

#### Chart - 10 - % of patients at the risk of CHD by: each variable
"""

# Chart - 10 visualization code
# 100% stacked bar chart

# Calculate the number of rows needed based on the number of categorical variables
num_rows = (len(categorical_var) - 1) // 3 + 1

# Create subplots with 3 columns
fig, axes = plt.subplots(num_rows, 3, figsize=(15, 5 * num_rows))

# Flatten the axes array for easy iteration
axes = axes.flatten()

# Iterate over categorical variables
for i, ax in zip(categorical_var[:-1], axes):
    x_var, y_var = i, dependent_var[0]

    # Calculate percentage and create 100% stacked bar chart
    df_grouped = df.groupby(x_var)[y_var].value_counts(normalize=True).unstack(y_var) * 100
    df_grouped.plot.barh(stacked=True, ax=ax)

    ax.legend(
        bbox_to_anchor=(1.05, 1),
        loc="upper left",
        title=y_var
    )

    ax.set_title("% of patients at the risk of CHD by: " + i)

    for ix, row in df_grouped.reset_index(drop=True).iterrows():
        cumulative = 0
        for element in row:
            if element > 0.1:
                ax.text(
                    cumulative + element / 2,
                    ix,
                    f"{int(element)} %",
                    va="center",
                    ha="center",
                )
            cumulative += element
# Hide any empty subplots
for j in range(len(categorical_var), len(axes)):
    axes[j].axis('off')

# Adjust layout to prevent overlap and show plot
plt.tight_layout()
plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a 100% stacked bar chart because it effectively illustrates the percentage distribution of individuals at risk of coronary heart disease across different categories of multiple categorical variables. This type of chart allows for easy comparison of the proportions within each category while maintaining the overall proportionality to 100%.

##### 2. What is/are the insight(s) found from the chart?

The insights from the 100% stacked bar chart would reveal the distribution of individuals at risk of coronary heart disease across various categories of categorical variables. For each categorical variable, the chart displays the percentage of individuals at risk of CHD within each category. Insights could include identifying categories with higher or lower proportions of individuals at risk, understanding the relative risk across different demographic or lifestyle factors, and potentially identifying patterns or trends that could inform targeted interventions or preventive measures.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained from the 100% stacked bar chart can help create a positive business impact by informing targeted interventions and preventive measures to reduce the risk of coronary heart disease. However, if the insights reveal disproportionately high risks within certain demographic or lifestyle categories, it could lead to negative growth if not addressed effectively, potentially resulting in increased healthcare costs or adverse health outcomes.

#### Chart - 11 - distribution of categorical variable
"""

# Chart - 11 visualization code
# Analysing the distribution of categorical variables in the dataset
import math

# Calculate the number of rows needed based on the number of categorical variables
num_vars = len(categorical_var)
num_cols = 3
num_rows = math.ceil(num_vars / num_cols)

# Create subplots
fig, axes = plt.subplots(num_rows, num_cols, figsize=(14, 5 * num_rows))

# Flatten the axes for easier iteration
axes = axes.flatten()

# Iterate through categorical variables
for i, cat_var in enumerate(categorical_var):
    plt.sca(axes[i])
    p = sns.countplot(x=cat_var, data=df)
    plt.xlabel(cat_var)
    plt.title(cat_var + ' distribution')

    # Annotate each bar with the count
    for bar in p.patches:
        plt.annotate(f'{bar.get_height()}', (bar.get_x() + bar.get_width() / 2., bar.get_height()),
                     ha='center', va='center', xytext=(0, 10), textcoords='offset points')

# Hide any empty subplots
for j in range(len(categorical_var), len(axes)):
    axes[j].axis('off')

# Adjust layout for better visualization
plt.tight_layout()
plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a countplot to analyze the distribution of categorical variables because it provides a clear visual representation of the frequency of each category within the dataset. This type of chart is effective for comparing the distribution of different categories across multiple variables, allowing for easy identification of patterns or disparities within the data. Additionally, annotating each bar with the count provides additional context and clarity to the visualization.

##### 2. What is/are the insight(s) found from the chart?

The insights from the chart highlight the imbalanced distribution of categorical variables, particularly in Bpmeds, Prevalentstroke, Prevalenthyp, diabetes, and the target variable TenYearCHD. This suggests that certain categories within these variables may be underrepresented or overrepresented compared to others, potentially impacting the robustness of predictive models and requiring careful consideration during analysis and model development.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained from identifying imbalanced distributions in categorical variables can help create a positive business impact by informing strategies to address data imbalance and improve the performance of predictive models. However, if not properly addressed, imbalanced data can lead to negative growth by causing biased model predictions, reduced model accuracy, and potentially overlooking minority classes or important patterns within the data. Therefore, it's essential to implement appropriate techniques such as oversampling, undersampling, or using advanced algorithms designed to handle imbalanced data to mitigate these negative impacts and ensure the reliability of the predictive models.

#### Chart - 12 - Distribution of continous variable
"""

# Chart - 12 visualization code
# Visualizing code of histogram plot & boxplot for each column to know the data distribution
for col in df.describe().columns:
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(16, 5))

    # Histogram with mean and median lines
    sns.histplot(df[col], ax=axes[0], kde=True)
    axes[0].axvline(df[col].mean(), color='red', linestyle='dashed', linewidth=2, label='Mean')
    axes[0].axvline(df[col].median(), color='blue', linestyle='dashed', linewidth=2, label='Median')
    axes[0].legend()

    # Boxplot with mean line
    sns.boxplot(df[col], ax=axes[1], orient='h', showmeans=True, color='cyan')

    fig.suptitle("Distribution plot of " + col, fontsize=15)
    plt.tight_layout()
    plt.show()

"""##### 1. Why did you pick the specific chart?

I chose to create a combination of histogram plots and boxplots for each column because this allows for a comprehensive visualization of the data distribution. The histogram provides insights into the shape and spread of the distribution, while the boxplot offers additional information on central tendency, variability, and potential outliers. By displaying both plots side by side, we can gain a more complete understanding of the distribution characteristics of each column in the dataset. Additionally, adding mean and median lines to the histogram provides further context on central tendency, aiding in interpretation. Overall, this combination of plots facilitates a deeper exploration of the dataset's numerical features.

##### 2. What is/are the insight(s) found from the chart?

The insights from the chart reveal the presence of outliers in the data, as indicated by data points extending beyond the whiskers of the boxplot. Additionally, the combination of histogram and boxplot visualizations highlights potential data imbalances and anomalies in the dataset's distribution, aiding in the identification of skewed or asymmetrical distributions and irregularities in central tendency.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained from identifying outliers and anomalies in the data can help create a positive business impact by informing data cleansing and preprocessing strategies to improve the quality and reliability of analytical models. However, if not properly addressed, these insights could lead to negative growth by compromising the accuracy and effectiveness of predictive models, resulting in biased or misleading conclusions that may adversely affect business decisions or outcomes. Therefore, addressing outliers and anomalies through appropriate data preprocessing techniques is crucial to ensure the reliability and effectiveness of subsequent analyses and business decisions.

#### Chart - 13 - Distribution Plot
"""

# Visualizing distributions using Histograms:
df.hist(figsize=(15, 15), grid=True);

"""##### 1. Why did you pick the specific chart?

I chose histograms for visualizing distributions because they provide a clear representation of the frequency distribution of numerical variables in the dataset. By plotting histograms for each numerical variable, we can quickly assess the shape, spread, and central tendency of the data, as well as identify any potential outliers or patterns within each variable. The use of histograms allows for a comprehensive exploration of the dataset's numerical characteristics in a single visualization, aiding in data exploration and understanding.

##### 2. What is/are the insight(s) found from the chart?

The insight from the histograms reveals that many of the numerical variables in the dataset exhibit skewness, indicating that their distributions are not symmetrical. Additionally, the presence of data imbalances suggests that certain values or ranges are more prevalent than others within these variables. These observations are important for understanding the characteristics of the dataset and may warrant further investigation into the underlying reasons for the skewness and imbalances, as well as consideration of appropriate data preprocessing techniques before conducting further analysis or modeling.

##### 3. Will the gained insights help creating a positive business impact?
Are there any insights that lead to negative growth? Justify with specific reason.

Yes, the insights gained from identifying skewness and data imbalance in the dataset can potentially lead to positive business impacts by informing data preprocessing strategies to improve the accuracy and reliability of analytical models. However, if not properly addressed, these insights could lead to negative growth by compromising the effectiveness of predictive models, resulting in biased or inaccurate predictions that may adversely affect business decisions or outcomes. Therefore, addressing skewness and data imbalance through appropriate preprocessing techniques is crucial to ensure the reliability and effectiveness of subsequent analyses and business decisions.

#### Chart - 14 - Correlation Heatmap
"""

# Identify non-numeric columns
non_numeric_columns = df.select_dtypes(exclude=['float', 'int']).columns

# Display non-numeric columns
print("Non-numeric columns:", non_numeric_columns)

# Handle non-numeric data
# For example, you can drop non-numeric columns
df_numeric = df.drop(columns=non_numeric_columns)

# Compute correlation matrix
correlation_matrix = df_numeric.corr()

# Visualize correlation matrix
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

"""##### 1. Why did you pick the specific chart?

I chose a heatmap of the correlation matrix because it effectively visualizes the relationships between numeric variables in the dataset. This allows for easy identification of patterns and strengths of correlations between different features, providing valuable insights into potential multicollinearity or dependencies among variables. The heatmap with annotated correlation values enhances readability and facilitates quick interpretation of the relationships within the dataset.

##### 2. What is/are the insight(s) found from the chart?

The insight from the correlation matrix heatmap indicates that there is significant correlation between the variables sysbp, diabp, and prevalenthyp. Specifically, sysbp and diabp exhibit a high correlation with each other, suggesting a strong linear relationship between systolic and diastolic blood pressure measurements. Additionally, both sysbp and diabp show a high correlation with the variable prevalenthyp, indicating a potential association between hypertension prevalence and blood pressure levels. This insight highlights the interrelatedness of these variables within the dataset, which could be important for understanding cardiovascular health and informing healthcare interventions or risk assessment strategies.

#### Chart - 15 - Pair Plot
"""

# Assuming df is your dataset and 'TenYearCHD' is the dependent feature
# Replace 'feature1', 'feature2', 'feature3' with your actual independent feature names
independent_features = ['age', 'education', 'cigsPerDay','BPMeds','prevalentStroke','prevalentHyp','diabetes','totChol','sysBP','diaBP','BMI','heartRate','glucose']
dependent_feature = 'TenYearCHD'

# Create scatter plots using a for loop
for feature in independent_features:
    # Scatter plot
    plt.figure(figsize=(8, 6))
    plt.scatter(df[feature][df[dependent_feature] == 0], df[dependent_feature][df[dependent_feature] == 0], label='No CHD', marker='o')
    plt.scatter(df[feature][df[dependent_feature] == 1], df[dependent_feature][df[dependent_feature] == 1], label='CHD', marker='s')

    # Set labels and title
    plt.xlabel(feature)
    plt.ylabel(dependent_feature)
    plt.title(f'Scatter Plot between {feature} and {dependent_feature}')
    plt.legend()

    # Show the plot
    plt.show()

"""##### 1. Why did you pick the specific chart?

I chose scatter plots to visualize the relationship between each independent feature and the dependent feature (TenYearCHD) because scatter plots are effective for examining the relationship between two continuous variables. By plotting the values of each independent feature against the dependent feature, we can visually assess any potential patterns, trends, or associations between them. Additionally, using different markers for the two classes (CHD and No CHD) allows for easy differentiation and interpretation of the data points. Overall, scatter plots provide a clear and intuitive way to explore the relationship between independent and dependent variables in the dataset.

##### 2. What is/are the insight(s) found from the chart?

The insights from the scatter plots reveal potential linear separability between the two classes (CHD and No CHD) for some independent features. Specifically, the straight lines formed by the data points suggest that certain independent features may serve as effective classifiers for distinguishing between individuals with and without coronary heart disease (CHD). This observation implies that these features may have significant predictive power in identifying individuals at risk of CHD, which could be valuable for risk assessment and decision-making in healthcare settings.

## ***5. Hypothesis Testing***

### Hypothetical Statement - 1

#### 1. State Your research hypothesis as a null hypothesis and alternate hypothesis.

Null Hypothesis (H0): The mean cholesterol levels (totChol) are the same for smokers and non-smokers.

Alternative Hypothesis (H1): There is a significant difference in mean cholesterol levels between smokers and non-smokers.

#### 2. Perform an appropriate statistical test.
"""

import pandas as pd
from scipy.stats import ttest_ind

# Separate data for smokers and non-smokers
smokers = df[df['is_smoking'] == 'YES']['totChol']
non_smokers = df[df['is_smoking'] == 'NO']['totChol']

# Perform t-test
t_statistic, p_value = ttest_ind(smokers, non_smokers, equal_var=False)

# Set your significance level (e.g., 0.05)
alpha = 0.05

# Print the results
print(f'T-statistic: {t_statistic}')
print(f'P-value: {p_value}')

# Check if the p-value is less than the significance level
if p_value < alpha:
    print("Reject the null hypothesis. There is a significant difference in mean cholesterol levels.")
else:
    print("Fail to reject the null hypothesis. No significant difference in mean cholesterol levels.")

"""##### Which statistical test have you done to obtain P-Value?

I used an independent two-sample t-test (ttest_ind) from the scipy.stats module to obtain the p-value. The t-test was applied to compare the mean cholesterol levels between two groups: smokers and non-smokers.

##### Why did you choose the specific statistical test?

I chose the independent two-sample t-test because it is appropriate when comparing the means of two independent groups, which is the case in your hypothesis. Here's the rationale:

1. **Nature of the Comparison:**
   - Your hypothesis involves comparing the mean cholesterol levels between two independent groups: smokers and non-smokers.

2. **Parametric Test:**
   - The t-test is a parametric test suitable for comparing means of continuous variables when certain assumptions are met. It assumes that the data follow a normal distribution and that the variances of the two groups are either equal or not significantly different.

3. **Continuous Outcome Variable:**
   - Cholesterol levels are continuous numerical data, making the t-test appropriate for comparing means.

4. **Two Independent Groups:**
   - The independent two-sample t-test is specifically designed for comparing means when dealing with two independent groups.

5. **Equal Variance Assumption:**
   - By setting `equal_var=False` in the `ttest_ind` function, the test is performed under the assumption of unequal variances between the two groups, which is a more robust choice when the variances are not assumed to be equal.

It's important to note that the appropriateness of a statistical test depends on the characteristics of your data and the assumptions of the test. In some cases, alternative tests (such as non-parametric tests) might be considered if assumptions are not met. Always ensure that the chosen statistical test aligns with the nature of your data and the objectives of your analysis.

### Hypothetical Statement - 2

#### 1. State Your research hypothesis as a null hypothesis and alternate hypothesis.

Null Hypothesis (H0): Age has no effect on the incidence of diabetes.

Alternative Hypothesis (H1): There is a significant association between age and the incidence of diabetes.

#### 2. Perform an appropriate statistical test.
"""

import statsmodels.api as sm
import pandas as pd


# Prepare the logistic regression model
X = df[['age']]
y = df['diabetes']
X = sm.add_constant(X)  # Add a constant term for the intercept

# Fit the logistic regression model
model = sm.Logit(y, X)
result = model.fit()

# Display the summary statistics
print(result.summary())

# Check if the p-value for 'age' is less than the significance level
if result.pvalues['age'] < 0.05:
    print("Reject the null hypothesis. There is a significant association between age and the incidence of diabetes.")
else:
    print("Fail to reject the null hypothesis. There is no significant association between age and the incidence of diabetes.")

"""##### Which statistical test have you done to obtain P-Value?

The statistical test used to obtain the p-value is the likelihood-ratio test associated with logistic regression. The logistic regression model is fitted using the Maximum Likelihood Estimation (MLE) method, and the likelihood-ratio test is used to assess the significance of the predictor variable 'age' in predicting the binary outcome 'diabetes.'

##### Why did you choose the specific statistical test?

I chose logistic regression for this analysis because the outcome variable, 'diabetes,' is binary (0 for no diabetes, 1 for diabetes), making it suitable for logistic regression, a type of regression analysis designed for binary outcomes. Here are the reasons for choosing logistic regression:

1. **Nature of the Outcome Variable:**
   - Logistic regression is appropriate for binary outcomes or outcomes that can be dichotomized. In this case, 'diabetes' is binary, making logistic regression a suitable choice.

2. **Log-Odds Transformation:**
   - Logistic regression models the log-odds of the probability of an event occurring. This is advantageous for binary outcomes as it allows the modeling of the relationship between predictors (in this case, 'age') and the likelihood of the event (diabetes) occurring.

3. **Handling Non-Linearity:**
   - Logistic regression can capture non-linear relationships between predictor variables and the log-odds of the outcome, providing flexibility in modeling complex relationships.

4. **Likelihood-Ratio Test:**
   - Logistic regression provides statistical tests, such as the likelihood-ratio test, for assessing the significance of predictor variables. This allows us to test hypotheses about the association between 'age' and 'diabetes.'

5. **Interpretability:**
   - Logistic regression coefficients can be interpreted as log-odds ratios, providing insights into the direction and strength of the relationship between the predictor and the outcome.

6. **Model Fit:**
   - Logistic regression is widely used in epidemiology and medical research for modeling binary outcomes, making it a common and well-established approach for analyzing this type of data.

It's crucial to choose a statistical test that aligns with the nature of your data and the research question at hand. Logistic regression, in this context, is a suitable choice for investigating the association between 'age' and the likelihood of 'diabetes' occurrence.

### Hypothetical Statement - 3

#### 1. State Your research hypothesis as a null hypothesis and alternate hypothesis.

Null Hypothesis (H0):
The mean age is the same for individuals with and without a 10-year risk of CHD.


Alternative Hypothesis (H1):
There is a significant difference in the mean age between individuals with and without a 10-year risk of CHD.

#### 2. Perform an appropriate statistical test.
"""

import pandas as pd
from scipy.stats import ttest_ind

# Assuming df is your DataFrame
# Drop any rows with missing values in 'TenYearCHD'
df_cleaned = df.dropna(subset=['TenYearCHD'])

# List to store results
test_results = []

# Numerical independent variables (excluding 'TenYearCHD')
numerical_variables = df_cleaned.select_dtypes(include='number').columns
numerical_variables = numerical_variables[numerical_variables != 'TenYearCHD']

# Significance level
alpha = 0.05

# Loop through each numerical independent variable
for variable in numerical_variables:
    # Split the data into two groups based on 'TenYearCHD'
    group_no_chd = df_cleaned[df_cleaned['TenYearCHD'] == 0][variable]
    group_chd = df_cleaned[df_cleaned['TenYearCHD'] == 1][variable]

    # Perform t-test
    t_statistic, p_value = ttest_ind(group_no_chd, group_chd)

    # Store results
    test_results.append({'Variable': variable, 'T-statistic': t_statistic, 'P-value': p_value})

    # Check for statistical significance
    if p_value < alpha:
        print(f"Reject the null hypothesis for {variable}. There is evidence that it is correlated with an increased risk of CHD.")
    else:
        print(f"Fail to reject the null hypothesis for {variable}. There is no significant evidence of a correlation between {variable} and CHD risk.")

# Convert results to DataFrame for easier inspection
results_df = pd.DataFrame(test_results)

# Display results
print(results_df)

"""##### Which statistical test have you done to obtain P-Value?

The statistical test used to obtain the p-values is the independent two-sample t-test. The t-test is applied to compare the means of two independent groups: individuals without a 10-year risk of Coronary Heart Disease (CHD) and individuals with a 10-year risk of CHD.

##### Why did you choose the specific statistical test?

The specific statistical test chosen in the provided code is the independent two-sample t-test. Here's why this test was chosen for comparing numerical independent variables between two groups:

1. **Nature of the Data:**
   - The data involves numerical independent variables, such as 'age,' and the comparison is between two groups: individuals with and without a 10-year risk of Coronary Heart Disease (CHD).

2. **Comparison of Means:**
   - The objective is to assess whether there is a significant difference in means between the two groups for each numerical variable.

3. **Two Independent Groups:**
   - The t-test is appropriate when comparing the means of two independent groups, which is the case here (individuals with and without a 10-year risk of CHD).

4. **Assumption of Normality:**
   - The t-test assumes that the data are approximately normally distributed. While robust to deviations from normality, the t-test is suitable when analyzing numerical data.

5. **Testing for Significance:**
   - The t-test provides a p-value that helps in testing the null hypothesis of equal means. If the p-value is below a chosen significance level (e.g., 0.05), it indicates that there is evidence to reject the null hypothesis.

6. **Ease of Interpretation:**
   - The results of the t-test are relatively easy to interpret, especially when assessing whether the means of two groups are statistically different.

While the t-test is a suitable choice for comparing means between two groups, it's important to consider the assumptions and limitations of the test. If the assumptions are not met or if dealing with non-numerical data, alternative tests might be considered. Always choose a statistical test that aligns with the nature of the data and the objectives of the analysis.

## ***6. Feature Engineering & Data Pre-processing***

### 1. Handling Missing Values
"""

# Define the imputation transformer
missing_value = ColumnTransformer([('impute_education', SimpleImputer(strategy='median'),[1]),
                                                ('impute_cigsPerDay', SimpleImputer(strategy='mean'),[4]),
                                                 ('impute_BPMeds', SimpleImputer(strategy='median'),[5]),
                                                ('impute_totChol', SimpleImputer(strategy='mean'),[9]),
                                                 ('impute_BMI', SimpleImputer(strategy='mean'),[10]),
                                                  ('impute_heartrate', SimpleImputer(strategy='mean'),[11])
                                                  ],
                                  remainder='passthrough')

#array after handling missing values
missing_value

"""### 2. Categorical Encoding"""

from sklearn.preprocessing import OneHotEncoder, OrdinalEncoder

#Define the enoding transformer
encoding = ColumnTransformer(
 [('ohe', OneHotEncoder(sparse=False, handle_unknown='ignore'), [7,8])]
 ,remainder='passthrough')

"""### 3. Handling Outliers"""

# from sklearn.base import BaseEstimator, TransformerMixin
# from sklearn.ensemble import IsolationForest

# # Custom transformer for outlier detection
# class OutlierDetectionTransformer(BaseEstimator, TransformerMixin):
#     def __init__(self, contamination=0.1):
#         self.contamination = contamination
#         self.detector = IsolationForest(contamination=self.contamination)

#     def fit(self, X, y=None):
#         self.detector.fit(X)
#         return self

#     def transform(self, X, y=None):
#         is_inlier = self.detector.predict(X)
#         return X[is_inlier == 1]

"""##### What all outlier treatment techniques have you used and why did you use those techniques?

### 4. Feature Selection
"""

# Define the feature selection transformer
feature_selection = SelectKBest(score_func=f_classif, k=5)

"""### 5. Data Scaling"""

# Define the feature scaling transformer
scaler = StandardScaler()

"""### 6. Data Transformation using Pipeline"""

pipe = Pipeline([
    ('missing_value',missing_value),
    ('encoding',encoding),
    ('feature_selection',SelectKBest(score_func=f_classif, k=5)),
    #('outlier_detector', OutlierDetectionTransformer(contamination=0.1)),
    ('scaler',StandardScaler())])

X_train_transformed = pipe.fit_transform(X_train, y_train)

X_test_transformed = pipe.transform(X_test)

X_train_transformed.shape

y_train.value_counts()

y_test.value_counts()

"""### 7. Data Splitting"""

# Split your data to train and test. Choose Splitting ratio wisely.
X = df_processed.drop("TenYearCHD", axis=1)
y = df_processed['TenYearCHD']

#splitting the data into 85/15 ration
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=6)

"""##### What data splitting ratio have you used and why?

###6.a handling imbalance
"""

from imblearn.over_sampling import SMOTE

# Apply SMOTE to the training data only
smote = SMOTE()
X_train_resampled, y_train_resampled = smote.fit_resample(X_train_transformed, y_train)

X_train_resampled.shape

y_train_resampled.shape

pd.DataFrame(X_train_resampled).info()

pd.DataFrame(y_train_resampled).info()

pd.DataFrame(X_test_transformed).info()

pd.DataFrame(y_test).info()

"""# ***7. ML Model Implementation***"""

from sklearn.metrics import classification_report, roc_curve, auc, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

def train_predict_evaluate_model(model, X_train_resampled, y_train_resampled, X_test_transformed, y_test):
    # Train the model
    model.fit(X_train_resampled, y_train_resampled)

    # Make predictions
    y_pred = model.predict(X_test_transformed)

    # Generate classification report
    print("Classification Report:")
    print(classification_report(y_test, y_pred))

    # Compute probabilities for ROC curve
    y_pred_proba = model.predict_proba(X_test_transformed)[:, 1]

    # Compute ROC curve and AUC
    fpr, tpr, _ = roc_curve(y_test, y_pred_proba)
    roc_auc = auc(fpr, tpr)

    # Plot ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='blue', lw=2, label='ROC curve (AUC = %0.2f)' % roc_auc)
    plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend(loc='lower right')
    plt.show()

    # Compute confusion matrix
    cm = confusion_matrix(y_test, y_pred)

    # Plot confusion matrix
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, cmap='Blues', fmt='g', cbar=False)
    plt.title('Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.show()

from sklearn.linear_model import LogisticRegression

# Create a Logistic Regression model
logistic_regression = LogisticRegression()

# Example usage of train_predict_evaluate_model function with Logistic Regression
train_predict_evaluate_model(logistic_regression, X_train_resampled, y_train_resampled, X_test_transformed, y_test)

# Define Decision Tree model
decision_tree = DecisionTreeClassifier()
# Example usage of train_predict_evaluate_model function with Decision Tree and hyperparameter grid
train_predict_evaluate_model(decision_tree, X_train_resampled, y_train_resampled, X_test_transformed, y_test)

from sklearn.ensemble import RandomForestClassifier

# Define Random Forest model
random_forest = RandomForestClassifier()

# Example usage of train_predict_evaluate_model function with Random Forest and hyperparameter grid
train_predict_evaluate_model(random_forest, X_train_resampled, y_train_resampled, X_test_transformed, y_test)

from sklearn.ensemble import GradientBoostingClassifier

# Define Gradient Boosting model
gradient_boosting = GradientBoostingClassifier()

# Example usage of train_predict_evaluate_model function with Gradient Boosting and hyperparameter grid
train_predict_evaluate_model(gradient_boosting, X_train_resampled, y_train_resampled, X_test_transformed, y_test)

from sklearn.svm import SVC

# Define Support Vector Machine (SVM) model with probability=True
svm = SVC(probability=True)

# Example usage of train_predict_evaluate_model function with SVM and hyperparameter grid
train_predict_evaluate_model(svm, X_train_resampled, y_train_resampled, X_test_transformed, y_test)

"""# **Conclusion**

Write the conclusion here.

### ***Hurrah! You have successfully completed your Machine Learning Capstone Project !!!***
"""